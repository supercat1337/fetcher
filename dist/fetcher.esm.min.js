var a=class{events={};on(t,e){typeof this.events[t]!="object"&&(this.events[t]=[]),this.events[t].push(e);let r=this,s=function(){r.removeListener(t,e)};return!/^(#has-listeners|#no-listeners)$/.test(t)&&this.events[t].length==1&&this.emit("#has-listeners",t),s}removeListener(t,e){var r;typeof this.events[t]=="object"&&(r=this.events[t].indexOf(e),r>-1&&(this.events[t].splice(r,1),!/^(#has-listeners|#no-listeners)$/.test(t)&&this.events[t].length==0&&this.emit("#no-listeners",t)))}emit(t){if(typeof this.events[t]=="object"){var e,r,s,n=[].slice.call(arguments,1);for(r=this.events[t].slice(),s=r.length,e=0;e<s;e++)try{r[e].apply(this,n)}catch(i){console.error(t,n),console.error(i)}}}once(t,e){return this.on(t,function r(){this.removeListener(t,r),e.apply(this,arguments)})}waitForEvent(t,e=0){return new Promise(r=>{let s,n=this.on(t,()=>{e>0&&clearTimeout(s),n(),r(!0)});e>0&&(s=setTimeout(()=>{n(),r(!1)},e))})}waitForAnyEvent(t,e=0){return new Promise(r=>{let s,n=[],i=()=>{e>0&&clearTimeout(s),n.forEach(l=>{l()}),r(!0)};t.forEach(l=>{n.push(this.on(l,i))}),e>0&&(s=setTimeout(()=>{i(),r(!1)},e))})}clear(){this.events={}}destroy(){this.clear()}clearEventListeners(t){(this.events[t]||[]).length>0&&(this.events[t]=[],this.emit("#no-listeners",t))}onHasEventListeners(t){return this.on("#has-listeners",t)}onNoEventListeners(t){return this.on("#no-listeners",t)}};var u="Fetch request aborted";function g(o={}){let t=o.retryCount||3,e=o.waitTime||1e3,r=o.eventEmitter||new a,s=o.customFetch||fetch;if(t<1)throw new Error("Retry count must be greater than 0.");let n=r||new a;return async(l,m)=>{for(let f=0;f<t;f++)try{return await s(l,m)}catch(c){if(c.name==u||f===t-1)throw c;await n.waitForEvent("cancel",e)}throw new Error("All retry attempts failed.")}}var h=class{#t;constructor(t){this.#t=t?t.bind(globalThis):fetch.bind(globalThis),this.controller=new AbortController,this.is_loading=!1}async fetch(t,e={}){this.is_loading&&this.cancel(),this.controller=new AbortController;let r=[this.controller.signal];e&&e.signal&&r.push(e.signal);let s=AbortSignal.any(r),n=Object.assign({},e,{signal:s});return this.is_loading=!0,await this.#t(t,n)}cancel(){this.controller.abort(u),this.is_loading=!1}};function b(o){let t=new h(o);return async(r,s)=>await t.fetch(r,s)}var E=class{#t=new a;cancel(){this.#t.emit("cancel"),this.#t.waitForEvent}createFetchFunction(t){let e=Object.assign({singleton:!0,retryCount:1,waitTime:1e3},t),r=g({...e,eventEmitter:this.#t}),s=new h(r);return this.#t.on("cancel",()=>{s.cancel()}),(i,l)=>s.fetch(i,l)}fetch(t,e){let r=new AbortController,s=[r.signal];e&&e.signal&&s.push(e.signal);let n=AbortSignal.any(s),i=this.#t.once("cancel",()=>{r.abort()});return(async(m,f)=>{try{let c=await fetch(m,f);return i(),r=null,c}catch(c){throw i(),r=null,c}})(t,Object.assign({},e,{signal:n}))}};export{u as FETCH_REQUEST_ABORTED,E as Fetcher,h as SingletonFetcher,g as createRetryFetch,b as createSingletonFetch};
